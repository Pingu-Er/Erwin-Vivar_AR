{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Not sure what to put here yet.</p> <p></p>"},{"location":"Act_UR5E_KUKA/","title":"Forward Kinematics (UR5e and KUKA KR16)","text":""},{"location":"Act_UR5E_KUKA/#1-introduction","title":"1. Introduction","text":"<ul> <li>UR5e (6-axis collaborative robot)</li> <li>KUKA KR16 (6-axis industrial robot)</li> </ul> <p>Forward kinematics computes the end-effector pose (position and orientation) with respect to the base frame, given:</p> <ul> <li>The robot geometric parameters (link lengths and offsets)</li> <li>The joint variables (joint angles for revolute joints)</li> </ul> <p>The result is typically expressed as a homogeneous transformation matrix:</p> \\[ {}^{0}T_{6}(\\mathbf{q}) = \\begin{bmatrix} {}^{0}R_{6}(\\mathbf{q}) &amp; {}^{0}p_{6}(\\mathbf{q}) \\\\ 0\\;0\\;0 &amp; 1 \\end{bmatrix} \\] <p>where:</p> <ul> <li>\\( {}^{0}R_{6} \\) is a 3\u00d73 rotation matrix</li> <li>\\( {}^{0}p_{6} \\) is a 3\u00d71 position vector</li> <li>\\( \\mathbf{q} = [q_1, q_2, q_3, q_4, q_5, q_6]^T \\)</li> </ul>"},{"location":"Act_UR5E_KUKA/#2-model-1-ur5e-forward-kinematics-dh-table","title":"2. Model 1: UR5e forward kinematics (DH table)","text":""},{"location":"Act_UR5E_KUKA/#21-notes-about-the-ur5e-model","title":"2.1 Notes about the UR5e model","text":"<p>UR5e is a 6-DOF serial manipulator with a 3-DOF wrist. The DH table below uses symbolic geometric parameters \\(L_1 \\dots L_6\\) and joint variables \\(q_1 \\dots q_6\\).</p> <p>Important modeling details:</p> <ul> <li>Angle offsets such as \\(-\\pi/2 + q_2\\) are part of the frame assignment. They shift the zero position of a joint so that the DH frames align with a chosen \u201chome\u201d configuration.</li> <li>Length parameters \\(L_i\\) must be defined in consistent units (all in meters or all in millimeters).</li> <li>The resulting \\( {}^{0}T_{6} \\) depends on the chosen base frame and the end-effector frame definition (tool flange vs TCP).</li> </ul>"},{"location":"Act_UR5E_KUKA/#22-image-placeholder-ur5e-diagram","title":"2.2 Image placeholder (UR5e diagram)","text":"<p>Insert the UR5e kinematic diagram here (before the table):</p> <p></p>"},{"location":"Act_UR5E_KUKA/#23-ur5e-dh-table-latex","title":"2.3 UR5e DH table (LaTeX)","text":"\\[ \\textbf{UR5e DH Parameters}= \\begin{array}{c|c|c|c|c} \\text{Link} &amp; a_i &amp; d_i &amp; \\alpha_i &amp; \\theta_i \\\\ \\hline 1 &amp; 0   &amp; L_1 &amp; \\frac{\\pi}{2}  &amp; q_1 \\\\ 2 &amp; L_1 &amp; 0   &amp; 0                &amp; -\\frac{\\pi}{2}+q_2 \\\\ 3 &amp; L_3 &amp; 0   &amp; 0                &amp; q_3 \\\\ 4 &amp; 0   &amp; L_4 &amp; \\frac{\\pi}{2}  &amp; -\\frac{\\pi}{2}+q_4 \\\\ 5 &amp; 0   &amp; L_5 &amp; -\\frac{\\pi}{2} &amp; q_5 \\\\ 6 &amp; 0   &amp; L_6 &amp; 0                &amp; -\\pi+q_6 \\end{array} \\]"},{"location":"Act_UR5E_KUKA/#24-how-to-compute-the-ur5e-forward-kinematics","title":"2.4 How to compute the UR5e forward kinematics","text":"<ol> <li>Build each \\( {}^{i-1}T_i \\) using the matrix definition in Section 2.2 and the parameters from the table.</li> <li>Substitute joint angles \\(q_i\\) (radians) and link constants \\(L_i\\).</li> <li>Multiply all transforms in order to get \\( {}^{0}T_{6} \\).</li> <li>Extract position and orientation from \\( {}^{0}T_{6} \\).</li> <li>If you have a TCP/tool offset, multiply by \\( {}^{6}T_{TCP} \\).</li> </ol>"},{"location":"Act_UR5E_KUKA/#3-model-2-kuka-kr16-forward-kinematics-dh-like-table","title":"3. Model 2: KUKA KR16 forward kinematics (DH-like table)","text":""},{"location":"Act_UR5E_KUKA/#31-notes-about-the-kr16-model","title":"3.1 Notes about the KR16 model","text":"<p>KUKA KR16 is a 6-DOF industrial manipulator. Many KR-series robots are modeled with a DH (or DH-like) parameterization. The table below uses the symbols:</p> <ul> <li>\\(L_i\\): translational parameter (commonly used as an offset along the z-axis in DH-like models)</li> <li>\\(D2_i\\): translational parameter (commonly used as a distance along the x-axis in DH-like models)</li> <li>\\(\\theta_i\\): joint angle (contains the variable \\(q_i\\) and possible constant offsets)</li> <li>\\(\\alpha_i\\): twist angle between axes</li> </ul> <p>This model is equivalent to the standard DH form if you interpret:</p> <ul> <li>\\(d_i \\leftarrow L_i\\)</li> <li>\\(a_i \\leftarrow D2_i\\)</li> </ul> <p>and use:</p> \\[ {}^{i-1}T_i = R_z(\\theta_i)\\,T_z(L_i)\\,T_x(D2_i)\\,R_x(\\alpha_i) \\] <p>As with the UR5e, constant angle terms (for example \\(\\pi/2\\) shifts) are tied to the chosen reference frames and the definition of the robot \u201czero\u201d configuration.</p>"},{"location":"Act_UR5E_KUKA/#32-image-placeholder-kr16-diagram","title":"3.2 Image placeholder (KR16 diagram)","text":"<p>Insert the KR16 kinematic diagram here (before the table):</p> <p></p>"},{"location":"Act_UR5E_KUKA/#33-kr16-parameter-table-latex","title":"3.3 KR16 parameter table (LaTeX)","text":"\\[ \\textbf{KUKA KR16 Parameters}= \\begin{array}{c|c|c|c|c} \\text{Link} &amp; L_i &amp; D2_i &amp; \\theta_i &amp; \\alpha_i \\\\ \\hline 1 &amp; -L_1      &amp; -L_2 &amp; q_1            &amp; -\\frac{\\pi}{2} \\\\ 2 &amp; 0         &amp; L_3  &amp; \\frac{\\pi}{2}+q_2 &amp; \\pi \\\\ 3 &amp; 0         &amp; 0    &amp; q_3            &amp; \\frac{\\pi}{2} \\\\ 4 &amp; L_4+L_5   &amp; 0    &amp; q_4            &amp; -\\frac{\\pi}{2} \\\\ 5 &amp; 0         &amp; 0    &amp; q_5            &amp; \\frac{\\pi}{2} \\\\ 6 &amp; -L_6      &amp; 0    &amp; q_6            &amp; \\pi \\end{array} \\]"},{"location":"Act_UR5E_KUKA/#34-how-to-compute-the-kr16-forward-kinematics","title":"3.4 How to compute the KR16 forward kinematics","text":"<ol> <li>Use the transform definition \\( {}^{i-1}T_i = R_z(\\theta_i)\\,T_z(L_i)\\,T_x(D2_i)\\,R_x(\\alpha_i) \\).</li> <li>Substitute link constants \\(L_i\\), \\(D2_i\\) and joint variables \\(q_i\\).</li> <li>Multiply the six transforms in order to obtain \\( {}^{0}T_{6} \\).</li> <li>Extract \\( {}^{0}p_{6} \\) and \\( {}^{0}R_{6} \\).</li> <li>Apply any TCP/tool transform if needed.</li> </ol>"},{"location":"Act_turtle/","title":"ROS Basics Capstone \u2013 Turtlesim Catch Them All","text":""},{"location":"Act_turtle/#1-overview","title":"1. Overview","text":"<p>The project is a multi-node ROS 2 application where:</p> <ul> <li><code>turtlesim_node</code> provides the simulator and built-in services (<code>/spawn</code>, <code>/kill</code>)</li> <li><code>turtle_spawner</code> spawns random turtles and manages the list of alive turtles</li> <li><code>turtle_controller</code> controls <code>turtle1</code> to chase and catch turtles</li> <li>Custom interfaces are used to share alive turtle information and request a catch action</li> </ul> <p>This report documents an implementation that was already completed, focusing on how each package, node, topic, and service contributes to the final behavior. The overall goal is to integrate ROS 2 basics (topics, services, custom interfaces, parameters, and launch files) in a single working application.</p>"},{"location":"Act_turtle/#2-project-objective","title":"2. Project objective","text":"<p>Implement a ROS 2 system that repeatedly spawns turtles in <code>turtlesim</code> and makes <code>turtle1</code> chase them automatically until they are removed.</p> <p>Main expected features (from the assignment instructions): - Spawn turtles at random positions - Publish a list of alive turtles - Control <code>turtle1</code> using a feedback controller - Request capture of a turtle through a custom service - Use a launch file and YAML parameters to start the system</p> <p>In practice, this capstone demonstrates a complete control loop: 1. Perception/state update (<code>/turtle1/pose</code>, <code>/alive_turtles</code>) 2. Decision (select nearest turtle) 3. Action (<code>/turtle1/cmd_vel</code>) 4. Task completion request (<code>/catch_turtle</code>) 5. Environment update (remove turtle and republish alive list)</p>"},{"location":"Act_turtle/#3-system-architecture","title":"3. System architecture","text":""},{"location":"Act_turtle/#nodes","title":"Nodes","text":"<ul> <li><code>turtlesim_node</code> (from <code>turtlesim</code>)</li> <li><code>turtle_spawner</code> (custom, package <code>er_turtle</code>)</li> <li><code>turtle_controller</code> (custom, package <code>er_turtle</code>)</li> </ul>"},{"location":"Act_turtle/#topics","title":"Topics","text":"<ul> <li><code>/turtle1/pose</code> (subscribe in controller)</li> <li><code>/turtle1/cmd_vel</code> (publish from controller)</li> <li><code>/alive_turtles</code> (publish from spawner, subscribe in controller)</li> </ul>"},{"location":"Act_turtle/#services","title":"Services","text":"<ul> <li><code>/spawn</code> (called by spawner)</li> <li><code>/kill</code> (called by spawner)</li> <li><code>/catch_turtle</code> (custom service offered by spawner, called by controller)</li> </ul> <p>This architecture separates responsibilities clearly: - <code>turtle_spawner</code> manages the \"world state\" of target turtles. - <code>turtle_controller</code> manages motion control and pursuit behavior. - <code>turtlesim_node</code> provides the simulation and native turtle management services.</p> <p>This separation is aligned with the assignment intent: use ROS 2 communication primitives to coordinate independent nodes.</p>"},{"location":"Act_turtle/#4-custom-interfaces-package-er_interfaces_turtle","title":"4. Custom interfaces package (<code>er_interfaces_turtle</code>)","text":"<p>This package defines the messages and service used by the controller and spawner.</p> <p>Custom interfaces are required because the default ROS 2 and turtlesim interfaces do not provide: - a compact list of all alive turtles with positions (<code>TurtleArray</code>) - a custom \"catch request\" semantic (<code>CatchTurtle</code>)</p>"},{"location":"Act_turtle/#41-turtleinmsg","title":"4.1 <code>TurtleIn.msg</code>","text":"<p>Purpose: - Represents a turtle entry in the alive list. - Stores the turtle name and its spawn pose.</p> <pre><code>string name\nfloat32 x\nfloat32 y\nfloat32 theta\n</code></pre> <p>Explanation: - <code>name</code>: turtle name (for example <code>turtle2</code>, <code>turtle3</code>, etc.) - <code>x</code>, <code>y</code>: turtle position used when spawned - <code>theta</code>: turtle heading used when spawned</p> <p>This message is the basic unit used by the spawner to publish tracked turtles and by the controller to choose a target.</p>"},{"location":"Act_turtle/#42-turtlearraymsg","title":"4.2 <code>TurtleArray.msg</code>","text":"<p>Purpose: - Publishes all currently alive turtles in one message.</p> <pre><code>TurtleIn[] turtles\n</code></pre> <p>Explanation: - <code>turtles</code> is an array of <code>TurtleIn</code> - This topic is published by <code>turtle_spawner</code> and read by <code>turtle_controller</code></p> <p>Using a single array message avoids publishing multiple topics or multiple services just to share the current list of targets. It also makes the controller logic simpler because it receives the full set of candidates in one callback.</p>"},{"location":"Act_turtle/#43-catchturtlesrv","title":"4.3 <code>CatchTurtle.srv</code>","text":"<p>Purpose: - Requests that one turtle be removed (caught) by name.</p> <pre><code>string name\n---\nbool success\n</code></pre> <p>Explanation: - Request:   - <code>name</code>: the turtle to remove - Response:   - <code>success</code>: whether the request was accepted and processed</p> <p>This service acts as the bridge between \"controller reached target\" and \"spawner updates the alive list + kills turtle in turtlesim\". It keeps the controller focused on motion and the spawner focused on entity management.</p>"},{"location":"Act_turtle/#44-notes-on-interface-package-build-files","title":"4.4 Notes on interface package build files","text":"<p>The interface package must use <code>rosidl_generate_interfaces(...)</code> in <code>CMakeLists.txt</code> and declare the correct dependencies in <code>package.xml</code> (<code>rosidl_default_generators</code>, <code>rosidl_default_runtime</code>, and <code>ament_cmake</code>).</p> <p>The uploaded interface <code>package.xml</code> identifies the package as:</p> <ul> <li><code>er_interfaces_turtle</code></li> </ul> <p>This matches the imports used in the Python nodes: - <code>from er_interfaces_turtle.msg import ...</code> - <code>from er_interfaces_turtle.srv import ...</code></p> <p>This consistency is important because any mismatch between package name, generated interfaces, and Python imports causes build/import errors.</p>"},{"location":"Act_turtle/#5-python-nodes-package-er_turtle","title":"5. Python nodes package (<code>er_turtle</code>)","text":"<p>This package contains the two custom nodes: - <code>turtle_spawner</code> - <code>turtle_controller</code></p> <p>It also includes <code>setup.py</code>/<code>setup.cfg</code> for registering executables.</p> <p>Functionally, this package is where the runtime behavior of the capstone lives: - one node manages target generation/removal - the other node performs guidance and pursuit</p>"},{"location":"Act_turtle/#5-turtle_spawnerpy-spawner-alive-list-manager-catch-service-server","title":"5. <code>turtle_spawner.py</code> (Spawner + alive list manager + catch service server)","text":""},{"location":"Act_turtle/#51-role-in-the-system","title":"5.1 Role in the system","text":"<p><code>MySpawner</code> is responsible for: - Spawning turtles periodically at random positions using <code>/spawn</code> - Keeping an internal list of alive turtles - Publishing that list to <code>alive_turtles</code> - Exposing <code>catch_turtle</code> service - Calling <code>/kill</code> when a turtle must be removed</p> <p>This node acts as the \"world manager\" for the capstone.</p> <p>It centralizes the logical state of active targets so the controller does not need to know how turtles are created or removed internally.</p>"},{"location":"Act_turtle/#52-main-ros-interfaces-used-by-turtle_spawner","title":"5.2 Main ROS interfaces used by <code>turtle_spawner</code>","text":"<ul> <li>Client: <code>spawn</code> (<code>turtlesim/srv/Spawn</code>)</li> <li>Client: <code>kill</code> (<code>turtlesim/srv/Kill</code>)</li> <li>Publisher: <code>alive_turtles</code> (<code>er_interfaces_turtle/msg/TurtleArray</code>)</li> <li>Service server: <code>catch_turtle</code> (<code>er_interfaces_turtle/srv/CatchTurtle</code>)</li> </ul> <p>The node uses both ROS 2 service client and server roles: - client role for interacting with <code>turtlesim</code> - server role for receiving \"catch\" requests from the controller</p> <p>This is one of the key integration points of the assignment.</p>"},{"location":"Act_turtle/#53-important-implementation-details","title":"5.3 Important implementation details","text":""},{"location":"Act_turtle/#parameters","title":"Parameters","text":"<p>The node declares and uses: - <code>spawn_frequency</code> (default <code>1.25</code>) - <code>turtle_name_prefix</code> (default <code>\"turtle\"</code>)</p> <p>These are later configured in the bringup YAML file.</p> <p>This allows the node behavior to be modified without changing code: - faster/slower spawn rate - different naming conventions</p>"},{"location":"Act_turtle/#internal-state","title":"Internal state","text":"<ul> <li><code>cnt_name</code>: starts at <code>2</code> (because <code>turtle1</code> already exists in turtlesim)</li> <li><code>alive_turtlesA</code>: stores the published alive turtle array</li> </ul> <p>Starting at <code>2</code> is important because <code>turtlesim_node</code> creates <code>turtle1</code> automatically, and the spawned turtles are intended to be targets (<code>turtle2</code>, <code>turtle3</code>, ...).</p>"},{"location":"Act_turtle/#random-spawning","title":"Random spawning","text":"<p>The node generates: - <code>x</code> in <code>[0.5, 10.5]</code> - <code>y</code> in <code>[0.5, 10.5]</code> - <code>theta</code> in <code>[-pi, pi]</code></p> <p>These ranges keep spawned turtles inside the visible map region and produce random headings for variety.</p>"},{"location":"Act_turtle/#catch-service-behavior","title":"Catch service behavior","text":"<p>When <code>catch_turtle</code> is called: - It calls <code>/kill</code> using the received turtle name - Removes the turtle from the internal alive list - Republishes the updated <code>alive_turtles</code> message</p> <p>Republishing after removal is essential so the controller always works with the current list and can immediately choose a new nearest target.</p>"},{"location":"Act_turtle/#55-full-code-turtle_spawnerpy","title":"5.5 Full code (<code>turtle_spawner.py</code>)","text":"<pre><code>#!/usr/bin/env python3\n\nimport numpy as np\nimport rclpy\nimport random\nfrom rclpy.node import Node\nfrom er_interfaces_turtle.msg import TurtleIn, TurtleArray\nfrom er_interfaces_turtle.srv import CatchTurtle\nfrom turtlesim.srv import Spawn, Kill\nfrom functools import partial\n\nclass MySpawner(Node):\n    def __init__(self):\n        super().__init__(\"turtle_spawner\") #Only identification          \n        self.client = self.create_client(Spawn,\"spawn\") #Service type, Service name\n\n        self.declare_parameter(\"spawn_frequency\", 1.25) #Declare parameter\n        self.spawn_frequency_ = self.get_parameter(\"spawn_frequency\").value #Use the parameter\n        self.create_timer(self.spawn_frequency_, self.t_spawner)\n\n        self.declare_parameter(\"turtle_name_prefix\", \"turtle\") #Declare parameter\n        self.turtle_name_prefix_ = self.get_parameter(\"turtle_name_prefix\").value #Use the parameter\n\n        self.cnt_name = 2\n        self.alive_turtlesA = TurtleArray()\n\n        self.alive_turtles_ = self.create_publisher(TurtleArray, \"alive_turtles\", 10)\n        self.catch_turtle_ = self.create_service(CatchTurtle, \"catch_turtle\", self.call_kill) #Service type, Service name, callback\n        self.client2 = self.create_client(Kill, \"kill\") #Service type, Service name\n\n    def call_spawn(self, save: TurtleIn):\n        while not self.client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"Server not available\")\n\n        request = Spawn.Request()\n        request.x = float(save.x)\n        request.y = float(save.y)\n        request.theta = float(save.theta)\n        request.name = str(save.name)\n\n        future = self.client.call_async(request)\n        future.add_done_callback(partial(self.add_spawn, request, save))\n\n    def add_spawn(self, request, save, future):\n        try:\n            response = future.result()\n            save.name = response.name\n\n            self.alive_turtlesA.turtles.append(save)\n            self.alive_turtles_.publish(self.alive_turtlesA)\n\n            self.get_logger().info(f\"Spawned requested='{request.name}' returned='{response.name}'\")\n\n        except Exception as e:\n            self.get_logger().error(f\"Spawn failed for {request.name}: {e}\")\n\n    def t_spawner(self):\n        save = TurtleIn()\n        save.name = self.turtle_name_prefix_ + str(self.cnt_name)\n        save.x = float(random.uniform(0.5, 10.5))\n        save.y = float(random.uniform(0.5, 10.5))\n        save.theta = float(random.uniform(-np.pi, np.pi))\n\n        self.call_spawn(save)\n\n        self.cnt_name += 1\n\n    def kill_la_kill(self, name:str):\n        while not self.client2.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\"Server not available\")\n\n        request = Kill.Request()\n        request.name = name\n\n        self.future = self.client2.call_async(request)\n        self.future.add_done_callback(partial(self.add_kill, request))\n\n    def add_kill(self, request: Kill.Request, future):\n        try:\n            future.result()\n\n            if self.remove_alive_turtle(request.name):\n                self.alive_turtles_.publish(self.alive_turtlesA)\n\n            self.get_logger().info(f\"Kill: {request.name}\")\n        except Exception as e:\n            self.get_logger().error(f\"Kill failed for {request.name}: {e}\")\n\n    def remove_alive_turtle(self, name: str):\n        for i, t in enumerate(self.alive_turtlesA.turtles):\n            if t.name == name:\n                del self.alive_turtlesA.turtles[i]\n                return True\n        return False\n\n    def call_kill(self, request: CatchTurtle.Request, response: CatchTurtle.Response):\n        self.kill_la_kill(request.name)\n        response.success = True\n        self.get_logger().info(f\"S= {response.success}\")\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    node = MySpawner()\n    rclpy.spin(node) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":  \n    main()\n</code></pre>"},{"location":"Act_turtle/#6-turtle_controllerpy-chaser-controller-catch-service-client","title":"6. <code>turtle_controller.py</code> (Chaser controller + catch service client)","text":""},{"location":"Act_turtle/#61-role-in-the-system","title":"6.1 Role in the system","text":"<p><code>TurtlePointController</code>: - Reads <code>turtle1</code> pose from <code>turtle1/pose</code> - Reads alive turtles from <code>alive_turtles</code> - Chooses the nearest turtle as target - Computes control commands (<code>linear.x</code>, <code>angular.z</code>) to chase it - Calls <code>catch_turtle</code> when the target is reached</p> <p>This is the intelligent behavior node of the capstone.</p> <p>Its main responsibility is not spawning or deleting turtles, but generating motion commands that make <code>turtle1</code> converge to the active target robustly and repeatedly.</p>"},{"location":"Act_turtle/#62-control-strategy-summary","title":"6.2 Control strategy summary","text":"<p>The controller uses:</p> <ul> <li>A discrete incremental PID for linear speed (distance error)</li> <li>A discrete incremental PID for angular speed (heading error)</li> <li>Saturation/anti-windup-style clipping for command limits</li> <li>Angle wrapping to keep angular error in <code>[-pi, pi]</code></li> <li>A cosine coupling term to reduce orbiting/loops</li> </ul> <p>Control variables: - Distance error: <code>distance = sqrt((gx-x)^2 + (gy-y)^2)</code> - Angular error: <code>alpha = wrap_pi(goal_angle - theta)</code></p> <p>A goal is considered reached when: - <code>distance &lt;= pos_tol</code></p> <p>At that moment: - The controller publishes zero velocity - Resets PID memory - Calls <code>catch_turtle</code> for the selected turtle name</p> <p>This behavior matches the assignment goal of autonomous pursuit-and-catch using ROS communication and feedback control.</p>"},{"location":"Act_turtle/#63-discrete-pid-incremental-form-used-in-the-code","title":"6.3 Discrete PID (incremental form) used in the code","text":"<p>The implementation is based on an incremental discrete PID form (as coded in <code>IncPid.step()</code>):</p> <pre><code>u[k] = u[k-1] + q0*e[k] + q1*e[k-1] + q2*e[k-2]\n</code></pre> <p>Where: - <code>u[k]</code> is the current control output - <code>e[k]</code> is the current error - <code>q0</code>, <code>q1</code>, <code>q2</code> are coefficients computed from continuous parameters (<code>kc</code>, <code>ti</code>, <code>td</code>) and sample time <code>Ts</code></p> <p>The code computes coefficients in <code>set_from_continuous(...)</code> and applies clipping with <code>clip_value(...)</code>.</p> <p>In this implementation: - one PID instance (<code>self.v_pid</code>) regulates the distance error and generates the linear speed reference - another PID instance (<code>self.w_pid</code>) regulates the heading error and generates the angular speed command</p> <p>Additionally, the linear command is multiplied by a cosine term based on <code>alpha</code>, which reduces forward motion when the turtle is not facing the target. This improves turning behavior and reduces circular trajectories around the goal.</p> <p></p>"},{"location":"Act_turtle/#64-main-tuninglimits-in-the-uploaded-implementation","title":"6.4 Main tuning/limits in the uploaded implementation","text":"<ul> <li>Sample time: <code>Ts = 0.05 s</code></li> <li>Position tolerance: <code>0.275</code></li> <li>Linear command limits: <code>[-12.0, 12.0]</code></li> <li>Angular command limits: <code>[-7.5, 7.5]</code></li> </ul> <p>Tuned PID values used in code: - Linear PID: <code>kc=2.25</code>, <code>ti=0.985</code>, <code>td=0.0275</code> - Angular PID: <code>kc=3.6</code>, <code>ti=0.65</code>, <code>td=0.0245</code></p> <p>These values define the response speed and smoothness of the pursuit behavior. The command limits are especially important in <code>turtlesim</code> to prevent excessive velocities that could make the trajectory unstable or visually erratic.</p>"},{"location":"Act_turtle/#66-full-code-turtle_controllerpy","title":"6.6 Full code (<code>turtle_controller.py</code>)","text":"<pre><code>#!/usr/bin/env python3\n\nimport numpy as np\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\nfrom turtlesim.msg import Pose\nfrom er_interfaces_turtle.msg import TurtleArray\nfrom er_interfaces_turtle.srv import CatchTurtle\nfrom functools import partial\n\n#Anti-windup/limits\ndef clip_value(x, xmin, xmax):\n    return float(np.clip(x, xmin, xmax))\n\n#Wrap for fast response\ndef wrap_pi(angle):\n    return float((angle + np.pi) % (2.0 * np.pi) - np.pi)\n\nclass IncPid:\n    def __init__(self, ts, umin, umax):\n        self.ts = ts\n        self.umin = umin\n        self.umax = umax\n\n        #Sample important states\n        self.e1 = 0.0   # e[k-1]\n        self.e2 = 0.0   # e[k-2]\n        self.u1 = 0.0   # u[k-1]\n\n        #Discrete coefficients\n        self.q0 = 0.0\n        self.q1 = 0.0\n        self.q2 = 0.0\n\n    def set_from_continuous(self, kc, ti=None, td=0.0):\n        Ts = self.ts\n\n        i_term = 0.0\n        if ti is not None and ti &gt; 0.0:\n            i_term = Ts / (2.0 * ti)\n\n        d_term = 0.0\n        if td &gt; 0.0:\n            d_term = td / Ts\n\n        #Incremental PID coefficient (discrete)\n        self.q0 = kc * (1.0 + i_term + d_term)\n        self.q1 = -kc * (1.0 - i_term + 2.0 * d_term)\n        self.q2 = kc * d_term\n\n    def reset(self, u0=0.0):\n        self.e1 = 0.0\n        self.e2 = 0.0\n        self.u1 = clip_value(u0, self.umin, self.umax)\n\n    def step(self, e):\n        u = self.u1 + self.q0 * e + self.q1 * self.e1 + self.q2 * self.e2\n        u = clip_value(u, self.umin, self.umax)\n\n        #Update past\n        self.e2 = self.e1\n        self.e1 = e\n        self.u1 = u\n\n        return float(u)\n\nclass TurtlePointController(Node):\n    def __init__(self):\n        super().__init__(\"turtle_controller\")\n\n        # ===== Sample time =====\n        self.ts = 0.05\n\n        # ===== Tolerances =====\n        self.pos_tol = 0.275\n        self.allow_reverse = False #My experiment, it is good for slow responses (kinda funny)\n\n        # ===== Command limits =====\n        self.v_min = -12.0\n        self.v_max =  12.0\n        self.w_min = -7.5\n        self.w_max =  7.5\n\n        # ===== Linear PID (distance) =====\n        self.v_pid = IncPid(ts=self.ts, umin=self.v_min, umax=self.v_max)\n        self.v_pid.set_from_continuous(kc=2.25, ti=0.985, td=0.0275)\n\n        # ===== Angular PID (alpha) =====\n        self.w_pid = IncPid(ts=self.ts, umin=self.w_min, umax=self.w_max)\n        self.w_pid.set_from_continuous(kc=3.6, ti=0.65, td=0.0245)\n\n        # ===== Current pose =====\n        self.x = 0.0\n        self.y = 0.0\n        self.theta = 0.0\n        self.pose_ok = False #Not necessary but just to be sure\n\n        # ===== Goal point =====\n        self.gx = 5.4444\n        self.gy = 5.4444\n        self.goal_ok = False #Not necessary but just to be sure\n        self.last_goal = (self.gx, self.gy)\n\n        # ===== Current errors =====\n        self.distance = 0.0 #Distance error\n        self.alpha = 0.0 #Orientation error\n\n        # ===== NAME =====\n        self.name_kill = \"\"\n\n        # ===== ROS interfaces =====\n        self.cmd_pub = self.create_publisher(Twist, \"turtle1/cmd_vel\", 10)\n        self.create_timer(self.ts, self.control_step)        \n\n        self.create_subscription(Pose, \"turtle1/pose\", self.pose_cb, 10)\n        self.create_subscription(TurtleArray, \"alive_turtles\", self.goal_cb, 10) #Will be modified\n\n        self.client = self.create_client(CatchTurtle,\"catch_turtle\")\n        self.last_kill = \"\"\n\n        self.log_counter = 0\n        self.get_logger().info(\"turtle_controller is alive\")\n\n\n    def callKILL(self, name: str):\n        while not self.client.wait_for_service(timeout_sec = 1.0):\n            self.get_logger().info(\"Server not available\")\n\n        request = CatchTurtle.Request()\n        request.name = name\n\n        self.future = self.client.call_async(request)   #asyncronous request\n        self.future.add_done_callback(partial(self.add_callKILL, request))\n\n    def add_callKILL(self, request: CatchTurtle.Request, future):\n        response = future.result()\n        self.get_logger().info(f\"S: {response.success} name={request.name}\")\n\n\n    def pose_cb(self, msg: Pose):\n        self.x = float(msg.x)\n        self.y = float(msg.y)\n        self.theta = float(msg.theta)\n        self.pose_ok = True\n\n    def goal_cb(self, msg: TurtleArray):\n        #No turtles\n        if not msg.turtles:\n            return\n\n        #Just in case, autodestruction\n        if not self.pose_ok:\n            return\n\n        nearest = min(msg.turtles, key=lambda t: (float(t.x) - self.x) ** 2 + (float(t.y) - self.y) ** 2)\n\n        self.name_kill = nearest.name\n        new_goal = (float(nearest.x), float(nearest.y))\n        self.gx, self.gy = new_goal\n        self.goal_ok = True\n\n        #Reset PID memory if goal changed noticeably (fast response)\n        dx = new_goal[0] - self.last_goal[0]\n        dy = new_goal[1] - self.last_goal[1]\n        if float(np.hypot(dx, dy)) &gt; 0.05:\n            self.v_pid.reset()\n            self.w_pid.reset()\n\n        self.last_goal = new_goal\n\n    def update_errors(self):\n        dx = self.gx - self.x\n        dy = self.gy - self.y\n\n        self.distance = float(np.hypot(dx, dy))\n\n        if self.distance &lt;= self.pos_tol:\n            self.alpha = 0.0\n            return\n\n        goal_angle = float(np.arctan2(dy, dx))\n        self.alpha = wrap_pi(goal_angle - self.theta)\n\n    def publish_stop(self):\n        msg = Twist()\n        msg.linear.x = 0.0\n        msg.angular.z = 0.0\n        self.cmd_pub.publish(msg)\n\n    def control_step(self):\n        if not self.pose_ok or not self.goal_ok:\n            return\n\n        self.update_errors()\n\n        #Stop condition (point reached)\n        if self.distance &lt;= self.pos_tol:\n            self.publish_stop()\n            self.v_pid.reset()\n            self.w_pid.reset()\n            if self.last_kill != self.name_kill:\n                self.callKILL(self.name_kill)\n                self.last_kill = self.name_kill\n            return\n\n        #Angular command\n        w_cmd = self.w_pid.step(self.alpha)\n\n        #Linear command from distance PID\n        v_pid_out = self.v_pid.step(self.distance)\n\n        #Coupling to reduce loops/orbits:\n        #linear speed decreases if heading error is large\n        c = float(np.cos(self.alpha))\n        if self.allow_reverse:\n            v_cmd = v_pid_out * c\n        else:\n            v_cmd = v_pid_out * max(0.0, c)\n\n        # Final clamp (after coupling)\n        v_cmd = clip_value(v_cmd, self.v_min, self.v_max)\n        w_cmd = clip_value(w_cmd, self.w_min, self.w_max)\n\n        # Publish\n        msg = Twist()\n        msg.linear.x = float(v_cmd)\n        msg.angular.z = float(w_cmd)\n        self.cmd_pub.publish(msg)\n\n        # Debug (every ~0.5 s)\n        self.log_counter += 1\n        if self.log_counter % 10 == 0:\n            self.get_logger().info(\n                f\"distance={self.distance:.4f} alpha={self.alpha:.4f} \"\n                f\"v={v_cmd:.4f} w={w_cmd:.4f} \"\n                f\"goal=({self.gx:.2f},{self.gy:.2f}) \"\n                f\"pose=({self.x:.2f},{self.y:.2f},{self.theta:.2f})\"\n            )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TurtlePointController()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Act_turtle/#7-setuppy-and-setupcfg-python-package-registration","title":"7. <code>setup.py</code> and <code>setup.cfg</code> (Python package registration)","text":""},{"location":"Act_turtle/#71-purpose","title":"7.1 Purpose","text":"<p>These files register the executable entry points so ROS 2 can run the Python nodes using:</p> <ul> <li><code>ros2 run er_turtle turtle_spawner</code></li> <li><code>ros2 run er_turtle turtle_controller</code></li> </ul> <p>This is required for <code>ament_python</code> packages because ROS 2 resolves executable names through the <code>console_scripts</code> declared in <code>setup.py</code>.</p>"},{"location":"Act_turtle/#72-setuppy-uploaded","title":"7.2 <code>setup.py</code> (uploaded)","text":"<pre><code>from setuptools import find_packages, setup\n\npackage_name = 'er_turtle'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=find_packages(exclude=['test']),\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='pingu',\n    maintainer_email='pingu@todo.todo',\n    description='TODO: Package description',\n    license='TODO: License declaration',\n    extras_require={\n        'test': [\n            'pytest',\n        ],\n    },\n    entry_points={\n        'console_scripts': [\n            'turtle_controller2 = er_turtle.turtle_controller2:main',\n            'turtle_controller = er_turtle.turtle_controller:main',\n            'turtle_spawner = er_turtle.turtle_spawner:main'\n        ],\n    },\n)\n</code></pre>"},{"location":"Act_turtle/#73-setupcfg-uploaded","title":"7.3 <code>setup.cfg</code> (uploaded)","text":"<pre><code>[develop]\nscript_dir=$base/lib/er_turtle\n[install]\ninstall_scripts=$base/lib/er_turtle\n</code></pre>"},{"location":"Act_turtle/#74-notes","title":"7.4 Notes","text":"<ul> <li>The uploaded <code>setup.py</code> includes an extra entry point:</li> <li><code>turtle_controller2 = er_turtle.turtle_controller2:main</code></li> <li>If <code>turtle_controller2.py</code> does not exist, that entry point should be removed to avoid runtime errors.</li> </ul> <p>For the capstone workflow, the important part is that <code>turtle_spawner</code> and <code>turtle_controller</code> are correctly registered, since both are referenced by the launch file.</p>"},{"location":"Act_turtle/#8-bringup-package-turtle_bringup","title":"8. Bringup package (<code>turtle_bringup</code>)","text":"<p>The bringup package starts the complete application and provides parameters for <code>turtle_spawner</code>.</p> <p>Using a dedicated bringup package is good practice because it keeps: - executable node code in one package (<code>er_turtle</code>) - custom interfaces in another (<code>er_interfaces_turtle</code>) - system startup/configuration files in a separate package (<code>turtle_bringup</code>)</p> <p>This improves organization and makes the system easier to reuse and test.</p>"},{"location":"Act_turtle/#81-launch-file-app_launch_turtlexml","title":"8.1 Launch file (<code>app_launch_turtle.xml</code>)","text":"<p>Purpose: - Starts <code>turtlesim_node</code> - Starts <code>turtle_spawner</code> and loads parameters from YAML - Starts <code>turtle_controller</code></p> <p>This file is the entry point for running the full demo in one command, which is one of the key expected outcomes of the capstone.</p> <pre><code>&lt;launch&gt;\n    &lt;node pkg=\"turtlesim\" exec=\"turtlesim_node\" /&gt;\n    &lt;node pkg=\"er_turtle\" exec=\"turtle_spawner\"&gt;\n        &lt;param from=\"$(find-pkg-share turtle_bringup)/config/t_param.yaml\" /&gt;\n    &lt;/node&gt;\n    &lt;node pkg=\"er_turtle\" exec=\"turtle_controller\" /&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"Act_turtle/#82-parameter-file-t_paramyaml","title":"8.2 Parameter file (<code>t_param.yaml</code>)","text":"<p>Purpose: - Configures <code>turtle_spawner</code> parameters from a centralized YAML file</p> <pre><code>turtle_spawner:\n    ros__parameters:\n        spawn_frequency: 1.25\n        turtle_name_prefix: \"turtle\"\n</code></pre> <p>Explanation: - <code>spawn_frequency</code>: timer period in seconds for spawning new turtles - <code>turtle_name_prefix</code>: prefix for generated names (<code>turtle2</code>, <code>turtle3</code>, ...)</p> <p>This keeps runtime tuning outside the source code and matches the assignment requirement of using parameters in a realistic ROS 2 setup.</p>"},{"location":"Act_turtle/#83-bringup-cmakeliststxt-uploaded","title":"8.3 Bringup <code>CMakeLists.txt</code> (uploaded)","text":"<p>Purpose: - Installs the <code>launch/</code> and <code>config/</code> directories into the package share directory</p> <p>This installation step is necessary so ROS 2 can find: - <code>app_launch_turtle.xml</code> - <code>t_param.yaml</code></p> <p>when executing <code>ros2 launch turtle_bringup app_launch_turtle.xml</code>.</p> <pre><code>cmake_minimum_required(VERSION 3.8)\nproject(turtle_bringup)\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\nfind_package(ament_cmake REQUIRED)\n\ninstall(DIRECTORY\n  launch\n  config\n  DESTINATION share/${PROJECT_NAME}/\n)\n\nament_package()\n</code></pre>"},{"location":"Act_turtle/#9-how-the-full-flow-works-step-by-step","title":"9. How the full flow works (step-by-step)","text":"<ol> <li><code>app_launch_turtle.xml</code> starts <code>turtlesim_node</code>, <code>turtle_spawner</code>, and <code>turtle_controller</code>.</li> <li><code>turtle_spawner</code> uses the YAML parameters to set spawn period and name prefix.</li> <li><code>turtle_spawner</code> periodically calls <code>/spawn</code> with random <code>(x, y, theta)</code>.</li> <li>Every successful spawn is added to the internal <code>alive_turtles</code> list and published.</li> <li><code>turtle_controller</code> receives <code>/alive_turtles</code>, selects the nearest turtle as current target.</li> <li><code>turtle_controller</code> reads <code>/turtle1/pose</code> and computes velocity commands using the discrete PID logic.</li> <li>When <code>turtle1</code> reaches the target (inside <code>pos_tol</code>), <code>turtle_controller</code> calls <code>catch_turtle</code>.</li> <li><code>turtle_spawner</code> receives <code>catch_turtle</code>, calls <code>/kill</code>, removes the turtle from the alive list, and republishes the updated list.</li> <li>The process repeats as new turtles continue spawning.</li> </ol> <p>This sequence directly reflects the intended integration of topics + services + custom interfaces described in the activity.</p>"},{"location":"Act_turtle/#10-useful-commands-from-assignment-workflow","title":"10. Useful commands (from assignment workflow)","text":""},{"location":"Act_turtle/#101-type-inspection","title":"10.1 Type inspection","text":"<pre><code>ros2 topic list -t\nros2 service list -t\nros2 action list -t\n</code></pre> <p>These commands help verify that: - the expected topics/services exist - the interface types match the implementation</p>"},{"location":"Act_turtle/#102-interface-structure-inspection","title":"10.2 Interface structure inspection","text":"<pre><code>ros2 interface show er_interfaces_turtle/msg/TurtleIn\nros2 interface show er_interfaces_turtle/msg/TurtleArray\nros2 interface show er_interfaces_turtle/srv/CatchTurtle\nros2 interface show turtlesim/srv/Spawn\nros2 interface show turtlesim/srv/Kill\n</code></pre> <p>These commands are especially useful during documentation and debugging because they confirm the exact fields used by the messages/services.</p>"},{"location":"Act_turtle/#103-verbose-connection-info","title":"10.3 Verbose connection info","text":"<pre><code>ros2 topic info /alive_turtles -v\nros2 topic info /turtle1/pose -v\nros2 topic info /turtle1/cmd_vel -v\nros2 service info /catch_turtle -v\nros2 service info /spawn -v\nros2 service info /kill -v\n</code></pre> <p>Use these commands to validate publishers/subscribers and service clients/servers, which is very helpful to demonstrate that the final graph matches the project architecture.</p>"},{"location":"Act_turtle/#11-terminal-and-results","title":"11. Terminal and results","text":"<p>Video of each node working toguether Demo video</p> <p>Image of launch .xml file result </p>"},{"location":"HW2/","title":"(HW2) Homework 2: Transform Nomenclature","text":""},{"location":"HW2/#excersice-1","title":"Excersice 1","text":"<p>The problem applies two active rotations to the vector \\(^{A}\\mathbf{P}\\). The rotations are executed in the indicated order:</p> <ol> <li>Rotate about the axis \\(\\hat{\\mathbf{Y}}_{A}\\) by \\(45^\\circ\\)</li> <li>Then rotate about the axis \\(\\hat{\\mathbf{X}}_{A}\\) by \\(60^\\circ\\)</li> </ol> <p>Mathematically:</p> \\[ \\mathbf{P}_T=\\mathbf{R}_y(\\theta)\\,\\mathbf{R}_x(\\alpha)\\,^{A}\\mathbf{P} \\] <p>Where:</p> \\[ \\mathbf{P}_T= \\begin{bmatrix} \\mathbf{P}_{Tx} \\\\ \\mathbf{P}_{Ty} \\\\ \\mathbf{P}_{Tz} \\end{bmatrix} \\hspace{1.5cm} ^{A}\\mathbf{P}= \\begin{bmatrix} \\mathbf{P}_{Ax} \\\\ \\mathbf{P}_{Ay} \\\\ \\mathbf{P}_{Az} \\end{bmatrix} \\] <p>Rotation about Y by \\(45^\\circ\\) and rotation about X by \\(60^\\circ\\):</p> \\[ \\mathbf{R}_y(45^\\circ)= \\begin{bmatrix} \\cos 45^\\circ &amp; 0 &amp; \\sin 45^\\circ\\\\ 0 &amp; 1 &amp; 0\\\\ -\\sin 45^\\circ &amp; 0 &amp; \\cos 45^\\circ \\end{bmatrix} \\;\\;\\;\\; \\mathbf{R}_x(60^\\circ)= \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\cos 60^\\circ &amp; -\\sin 60^\\circ\\\\ 0 &amp; \\sin 60^\\circ &amp; \\cos 60^\\circ \\end{bmatrix} \\] <p>Simplifing in one general rotation matriz</p> \\[ \\mathbf{R}=\\mathbf{R}_y(45^\\circ)\\,\\mathbf{R}_x(60^\\circ) \\] <p>Numeric result:</p> \\[ \\mathbf{R}= \\begin{bmatrix} 0.7071 &amp; 0.6124 &amp; 0.3536 \\\\ 0 &amp; 0.5 &amp; -0.866 \\\\ -0.7071 &amp; 0.6124 &amp; 0.3536 \\end{bmatrix} \\]"},{"location":"HW2/#exercise-2","title":"Exercise 2","text":"<p>In this exercise, the frame \\(\\{B\\}\\) is defined with respect to \\(\\{A\\}\\) by:</p> <ul> <li>A rotation about the axis \\(\\hat{\\mathbf{X}}_{A}\\) of \\(30^\\circ\\)</li> </ul> \\[ \\mathbf{R}_x(30^\\circ)= \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; \\cos 30^\\circ &amp; -\\sin 30^\\circ\\\\ 0 &amp; \\sin 30^\\circ &amp; \\cos 30^\\circ \\end{bmatrix} \\] <ul> <li>A translation of \\(\\{B\\}\\) from \\(\\{A\\}\\) given by:</li> </ul> \\[ ^{A}_{B}\\mathbf{t}= \\begin{bmatrix} 5\\\\ 10\\\\ 0 \\end{bmatrix} \\] <p>A homogeneous transformation matrix is built by placing the rotation matrix and translation vector in block form:</p> \\[ ^{A}_{B}\\mathbf{T}= \\begin{bmatrix} ^{A}_{B}\\mathbf{R} &amp; ^{A}_{B}\\mathbf{t}\\\\ 0 &amp; 1 \\end{bmatrix} \\] <p>For this case, \\(^{A}_{B}\\mathbf{R}=\\mathbf{R}_x(30^\\circ)\\) and \\(^{A}_{B}\\mathbf{t}=[5\\;\\;10\\;\\;0]^{\\mathsf{T}}\\), therefore:</p> \\[ ^{A}_{B}\\mathbf{T}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 5\\\\ 0 &amp; \\cos 30^\\circ &amp; -\\sin 30^\\circ &amp; 10\\\\ 0 &amp; \\sin 30^\\circ &amp; \\cos 30^\\circ &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 5\\\\ 0 &amp; 0.866 &amp; -0.5 &amp; 10\\\\ 0 &amp; 0.5 &amp; 0.866 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>This means that the pose of frame \\(\\{B\\}\\) with respect to frame \\(\\{A\\}\\) is:</p> \\[ ^{A}_{B}\\mathbf{P} = ^{A}_{B}\\mathbf{T}\\;\\mathbf{P}_{A} \\]"},{"location":"HW2/#exercise-3","title":"Exercise 3","text":"<p>This exercise is divided into two parts:</p> <ol> <li>A translation and rotation from point \\(\\mathbf{A}\\) to point \\(\\mathbf{B}\\)</li> <li>A translation and rotation from point \\(\\mathbf{A}\\) to point \\(\\mathbf{C}\\)</li> </ol> <p>Definition of homogeneous transformation matrix (from A to B)</p> <p>The homogeneous transformation matrix is equivalent to translating 3 units along the \\(\\hat{\\mathbf{X}}_{A}\\) axis and then applying a 180\u00b0 rotation around the \\(\\hat{\\mathbf{Z}}_{A}\\) axis. Mathematically, this is:</p> \\[ ^{B}_{A}\\mathbf{T}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 3\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} \\cos 180^\\circ &amp; -\\sin 180^\\circ &amp; 0 &amp; 0\\\\ \\sin 180^\\circ &amp; \\cos 180^\\circ &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}= \\begin{bmatrix} -1 &amp; 0 &amp; 0 &amp; 3\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>Definition of homogeneous transformation matrix (from A to C)</p> <p>The homogeneous transformation matrix is equivalent to translating 3 units along the \\(\\hat{\\mathbf{X}}_{A}\\) and 2 units along the \\(\\hat{\\mathbf{Z}}_{A}\\) axis. Then applying a 90\u00b0 rotation around the \\(\\hat{\\mathbf{Y}}_{A}\\) axis and finally a -30\u00b0 rotation around the \\(\\hat{\\mathbf{X}}_{A}\\).Mathematically, this is:</p> \\[ ^{C}_{A}\\mathbf{T}= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 3\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} \\cos 90^\\circ &amp; 0 &amp; \\sin 90^\\circ &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ -\\sin 90^\\circ &amp; 0 &amp; \\cos 90^\\circ &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\cos -30^\\circ &amp; -\\sin -30^\\circ  &amp; 0\\\\ 0 &amp; \\sin -30^\\circ  &amp; \\cos -30^\\circ &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>Simplifying:</p> \\[ ^{C}_{A}\\mathbf{T}= \\begin{bmatrix} 0 &amp; -0.5 &amp; 0.866 &amp; 3\\\\ 0 &amp; 0.866 &amp; 0.5 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"HW_1/","title":"(HW1) Homework 1: Examples of robots by morphology","text":""},{"location":"HW_1/#cartesian-ppp","title":"Cartesian (PPP)","text":"<p>G\u00fcdel gantryRobot</p> <p></p> <p>A modular cartesian industrial robot for high-accuracy handling integrated into automation cells. Widely used in industries like automotive and intralogistics.</p> <ul> <li>Advantages<ul> <li>Very high stiffness and repeatability.</li> <li>Large rectangular workspace and easy to scale.</li> </ul> </li> <li>Disadvantages<ul> <li>Big structure, therefore, can be heavy and expensive at large spans.</li> <li>Cable management and moving mass on long axes can limit dynamics.</li> </ul> </li> </ul>"},{"location":"HW_1/#scara-rrp","title":"SCARA (RRP)","text":"<p>OMRON eCobra</p> <p></p> <p>A 4-axis industrial robot launched in 2016 and used nowadays for high-precision automation, including electronics and pharmaceutical-oriented environments.</p> <ul> <li>Advantages<ul> <li>High speed with good repeatability (planar motion is very efficient).</li> <li>High stiffness in the vertical axis (good for \u201cdownward\u201d interactions).</li> </ul> </li> <li>Disadvantages<ul> <li>Limited orientation capability (mainly about Z).</li> <li>Not as flexible as other articulated robots for awkward poses (the workspace is a toroid).</li> </ul> </li> </ul>"},{"location":"HW_1/#articulated-rrr","title":"Articulated (RRR)","text":"<p>Universal Robots UR5e</p> <p></p> <p>A 6-axis collaborative robot introduced in 2018. It has integrated torque sensor for compliant interaction.</p> <ul> <li>Advantages<ul> <li>Highest dexterity (reach around obstacles).</li> <li>Adaptable to various geometric spaces.</li> </ul> </li> <li>Disadvantages<ul> <li>More complex kinematics and calibration.</li> <li>Joint limits are a real planning constraint.</li> <li>Often slower and less stiff than PPP/SCARA.</li> </ul> </li> </ul>"},{"location":"HW_1/#spherical-polar-rrp","title":"Spherical / Polar (RRP)","text":"<p>A manipulator designed by Victor Scheinman at Stanford (1969). It uses two revolute joints plus a long prismatic \u201ctelescoping\u201d link (RRP) to sweep a distinctly spherical/polar workspace.</p> <ul> <li>Advantages<ul> <li>Fewer joints while still covering many directions.</li> <li>It can be mechanically simple for certain radial/angular motions.</li> </ul> </li> <li>Disadvantages<ul> <li>Accuracy and stiffness vary with radius.</li> <li>More awkward to fit into rectangular workcells.</li> <li>Not as common today.</li> </ul> </li> </ul>"},{"location":"HW_1/#cylindrical-rpp","title":"Cylindrical (RPP)","text":"<p>JEL MCR3160C</p> <p></p> <p>A 3-axis clean robot designed for wafer handling in semiconductor production/inspection lines.</p> <ul> <li>Advantages<ul> <li>Simple and with robust kinematics.</li> <li>Often clean cable routes (axis separation is mechanically clear).</li> </ul> </li> <li>Disadvantages<ul> <li>Limited dexterity/orientation.</li> </ul> </li> </ul>"},{"location":"HW_1/#delta-parallel","title":"Delta (Parallel)","text":"<p>ABB IRB 360 FlexPicker</p> <p></p> <p>Parallel robot optimized for high-speed picking and packing introduced in 2008.</p> <ul> <li>Advantages<ul> <li>Mechanically efficient for rapid point-to-point motion.</li> <li>High repeatability in a defined \u201cdome-like\u201d workspace.</li> </ul> </li> <li>Disadvantages<ul> <li>Not ideal for long-reach or heavy payload relative to size.</li> <li>Limited workspace volume and orientation.</li> </ul> </li> </ul>"},{"location":"HW_1/#resources","title":"Resources","text":"Bibliography <p>[1] Texas Instruments, \u201cAn engineer\u2019s guide to industrial robot designs,\u201d Texas Instruments, PDF. Accessed: Jan. 27, 2026. [Online]. Available: https://www.ti.com/lit/eb/ssiy006/ssiy006.pdf</p> <p>[2] G\u00fcdel Group, \u201cGantry robots (gantryRobot),\u201d gudel.com. Accessed: Jan. 27, 2026. [Online]. Available: https://www.gudel.com/products/robots/gantry-robot</p> <p>[3] OMRON Robotics, \u201ceCobra SCARA Robot for Precision &amp; Speed,\u201d robotics.omron.com. Accessed: Jan. 27, 2026. [Online]. Available: https://robotics.omron.com/products/industrial-robots/scara/ecobra/</p> <p>[4] Universal Robots, \u201cUR5e e-Series datasheet,\u201d Universal Robots, PDF. Accessed: Jan. 27, 2026. [Online]. Available: https://www.universal-robots.com/media/1807465/ur5e_e-series_datasheets_web.pdf</p> <p>[5] Stanford University, \u201cStanford\u2019s robotics legacy,\u201d Stanford News, Jan. 16, 2019, accessed Jan. 27, 2026. [Online]. Available: https://news.stanford.edu/2019/01/16/stanfords-robotics-legacy/</p> <p>[6] JEL Corporation, \u201cProducts | MCR3160C | Wafer Transfer Atmospheric Robot,\u201d jel-robot.com. Accessed: Jan. 27, 2026. [Online]. Available: https://www.jel-robot.com/products/MCR3160C.html</p> <p>[7] ABB, \u201cIRB 360 FlexPicker\u00ae \u2014 Greater flexibility in a compact footprint,\u201d ABB Robotics, Brochure ROB0082EN_G, PDF. Accessed: Jan. 27, 2026. [Online]. Available: https://search.abb.com/library/Download.aspx?DocumentID=ROB0082EN_G</p>"},{"location":"HW_3/","title":"(HW3) Homework 3: Forward Kinematics","text":"<p>For the following problems, we used Matlab to solve all the matrices. The script calculates the matrices both individually (between each frame) and calculates the homogeneous transformation matrix between frame 0 and the frame associated with the final element of the robot.</p> <p>The Matlab script was the following:</p> <pre><code>%% Denavit\u2013Hartenberg (table Evaluator)\n% Computes individual link transforms (A_i) and cumulative transforms T_0_i.\n\n% Notes:\n% - Angles are in radians.\n% - This script can be configured for different types of joints.\n\n\n% -------------------- Local Function: Standard DH homogeneous transform --------------------\nfunction H = dhStandard(a, alpha, d, theta)\n\nct = cos(theta);  st = sin(theta);\nca = cos(alpha);  sa = sin(alpha);\n\nH = [ ct, -st*ca,  st*sa, a*ct;\n      st,  ct*ca, -ct*sa, a*st;\n      0,      sa,     ca,    d;\n      0,       0,      0,    1 ];\nend\n% -------------------- Local Function --------------------\n\nclear; clc;\n\n% -------------------- Parameters --------------------\n% Notes:\n% - In the case of joints with negligible distance between them, L = 0.\n\nl1 = 0;\nl2 = 1;\nl3 = 0;\nl4 = 1;\nl5 = 0;\nl6 = 1;\n\n% It is assumed that q = 0 for the initial pose.\nq = zeros(6,1);\n\n% -------------------- DH Table (Standard) --------------------\n% Columns: a [m], alpha [rad], d [m], theta [rad]\nDH = table( ...\n    [0;   l2;  0;   0;   0;   0], ...\n    [pi/2;pi/2;-pi/2;pi/2;-pi/2;0], ...\n    [0;   0;   0;   l4;  0;   l6], ...\n    [pi/2+q(1); pi/2+q(2); q(3); q(4); q(5); -pi/2+q(6)], ...\n    'VariableNames', {'a','alpha','d','theta'} );\n\nN = height(DH);\n\n% -------------------- Compute A_i and T_0_i --------------------\nA = cell(N,1); % A{i} = A_i\nT = cell(N,1); % T{i} = T_0_i\n\nTcum = eye(4);\nfor i = 1:N\n    A{i} = dhStandard(DH.a(i), DH.alpha(i), DH.d(i), DH.theta(i));\n    Tcum = Tcum * A{i};\n    T{i} = Tcum;\nend\n\n% -------------------- Display Results --------------------\ndisp(\"=== Evaluated DH Table (Standard DH) ===\");\ndisp(DH);\n\nfor i = 1:N\n    fprintf(\"\\nA_%d =\\n\", i);\n    disp(A{i});\nend\n\nT_0_N = T{end};\ndisp(\"=== T_0_N (end-effector pose) ===\");\ndisp(T_0_N);\n</code></pre> <p>It is important to note that a link length of 1 was assumed for every link whenever its length could not be considered negligible. Additionally, the script was evaluated using the initial configuration, \\(q=0\\). These assumptions were adopted to keep the focus strictly on the kinematic analysis of the robots and on the systematic generation of Denavit\u2013Hartenberg transformation matrices.</p>"},{"location":"HW_3/#excersice-1","title":"Excersice 1","text":"<p>Result (image of planes, origins, axis, links):</p> <p>DH parameters</p> L a \u03b1 \u03b8 d 1 \\(l_{1.2}\\) \\(-\\pi/2\\) \\(-\\pi/2 + q_1\\) \\(0\\) 2 \\(0\\) \\(0\\) \\(0\\) \\(l_{1.1}+l_2+q_2\\) <p>DH after sustitution (script): </p> \\[ \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 1 &amp; -1.5708 &amp; 0 &amp; -1.5708\\\\ 0 &amp; 0 &amp; 2 &amp; 0 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0  &amp; 0  &amp; 1 &amp; 0\\\\ -1 &amp; 0  &amp; 0 &amp; -1\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{2}T= \\begin{bmatrix} 0  &amp; 0 &amp; 1 &amp; 2\\\\ -1 &amp; 0 &amp; 0 &amp; -1\\\\ 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"HW_3/#excersice-2","title":"Excersice 2","text":"<p>Result (image of planes, origins, axis, links):</p> <p>DH parameters</p> L a \u03b1 \u03b8 d 1 \\(0\\) \\(\\pi/2\\) \\(\\pi/2\\) \\(l_1 + q_1\\) 2 \\(0\\) \\(\\pi/2\\) \\(\\pi/2\\) \\(l_2 + q_2\\) 3 \\(0\\) \\(\\pi\\) \\(0\\) \\(l_3 + q_3\\) <p>DH after sustitution (script): </p> \\[ \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta &amp;\\\\ \\hline 0 &amp; 1.5708 &amp; 1 &amp; 1.5708 &amp;\\\\646 0 &amp; 3.1416 &amp; 1 &amp; 0 &amp; \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{3}T= \\begin{bmatrix} 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; -1 &amp; 1\\\\ 1 &amp; -0 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"HW_3/#excersice-3","title":"Excersice 3","text":"<p>Result (image of planes, origins, axis, links):</p> <p>DH parameters</p> L a \u03b1 \u03b8 d 1 \\(0\\) \\(-\\pi/2\\) \\(q_1\\) \\(l_1\\) 2 \\(l_2\\) \\(0\\) \\(q_2\\) \\(0\\) 3 \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_3\\) \\(0\\) 4 \\(0\\) \\(-\\pi/2\\) \\(\\pi/2+q_4\\) \\(l_3+l_4\\) 5 \\(0\\) \\(\\pi/2\\) \\(q_5\\) \\(0\\) 6 \\(0\\) \\(0\\) \\(q_6\\) \\(l_5+l_6\\) <p>DH after sustitution (script):</p> \\[ \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; -1.5708 &amp; 1 &amp; 0\\\\ 1 &amp; 0       &amp; 0 &amp; 0\\\\ 0 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 2 &amp; 1.5708\\\\ 0 &amp; 1.5708  &amp; 0 &amp; 0\\\\ 0 &amp; 0       &amp; 2 &amp; 0 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 0 &amp; 0 &amp; -1 &amp; 0\\\\ 1 &amp; 0 &amp; 0  &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 2\\\\ 0 &amp; 0  &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 5\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"HW_3/#excersice-4","title":"Excersice 4","text":"<p>Result (image of planes, origins, axis, links):</p> <p>DH parameters</p> L \\(d_z\\) a \u03b1 \u0398 1 \\(l_1\\) \\(0\\) \\(-\\pi/2\\) \\(q_1\\) 2 \\(0\\) \\(l_2\\) \\(0\\) \\(q_2\\) 3 \\(-l_3\\) \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_3\\) 4 \\(l_4\\) \\(0\\) \\(-\\pi/2\\) \\(q_4\\) 5 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(-\\pi/2+q_5\\) 6 \\(l_6\\) \\(0\\) \\(0\\) \\(q_6\\) <p>DH after sustitution (script): </p> \\[ \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; -1.5708 &amp; 1  &amp; 0\\\\ 1 &amp; 0       &amp; 0  &amp; 0\\\\ 0 &amp; 1.5708  &amp; -1 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 1  &amp; 0\\\\ 0 &amp; 1.5708  &amp; 0  &amp; -1.5708\\\\ 0 &amp; 0       &amp; 1  &amp; 0   \\end{array} \\] \\[ T_1= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 0 &amp; 0 &amp; -1 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 2\\\\ 0 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"HW_3/#excersice-5","title":"Excersice 5","text":"<p>Result (image of planes, origins, axis, links):</p> <p>DH parameters</p> L \\(d_z\\) a \u03b1 \u03b8 1 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_1\\) 2 \\(0\\) \\(l_2\\) \\(-\\pi/2\\) \\(\\pi/2+q_2\\) 3 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(q_3\\) 4 \\(l_4\\) \\(0\\) \\(\\pi/2\\) \\(q_4\\) 5 \\(0\\) \\(0\\) \\(-\\pi/2\\) \\(q_5\\) 6 \\(l_6\\) \\(0\\) \\(0\\) \\(-\\pi/2+q_6\\) <p>DH after sustitution (script):</p> \\[ \\begin{array}{c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 1 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 0 &amp; 0\\\\ 0 &amp; 1.5708  &amp; 1 &amp; 0\\\\ 0 &amp; -1.5708 &amp; 0 &amp; 0\\\\ 0 &amp; 0       &amp; 1 &amp; -1.5708 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 2\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"ROS2_Custom_Interfaces/","title":"(A3) Activity 3: ROS 2 Custom Interfaces","text":""},{"location":"ROS2_Custom_Interfaces/#overview","title":"Overview","text":"<p>This activity extends the services workflow by introducing custom ROS 2 interfaces (one <code>.msg</code> and one <code>.srv</code>) and integrating them into a two-node system:</p> <ul> <li>A Battery node simulates the battery level and acts as a service client.</li> <li>An LED panel node exposes a service server (<code>/set_led</code>) and publishes the LED panel state on a topic (<code>/led_panel_state</code>).</li> </ul> <p>Conceptually, the goal is to use a service request to toggle an LED depending on battery state: when the battery becomes empty, an LED is powered ON, and when it becomes full again, it is powered OFF.</p> <p></p>"},{"location":"ROS2_Custom_Interfaces/#system-architecture","title":"System Architecture","text":"<p>Nodes</p> <ol> <li> <p><code>Battery_node</code> </p> <ul> <li>Service client for: <code>/set_led</code></li> </ul> </li> <li> <p><code>LED_panel_node</code> </p> <ul> <li>Service server for: <code>/set_led</code></li> <li>Topic publisher for: <code>/led_panel_state</code></li> </ul> </li> </ol> <p>Interfaces</p> <ul> <li>Custom service: <code>LEDpanel.srv</code> (used by <code>/set_led</code>)</li> <li>Custom message: <code>BatStatus.msg</code> (used by <code>/led_panel_state</code>)</li> </ul>"},{"location":"ROS2_Custom_Interfaces/#custom-interfaces","title":"Custom Interfaces","text":"<p>Before implementing the nodes, a dedicated interfaces package (in this case, <code>er_interfaces</code>) is used to define and build the custom service and message types.</p>"},{"location":"ROS2_Custom_Interfaces/#service-definition-ledpanelsrv","title":"Service definition: <code>LEDpanel.srv</code>","text":"<p>The service definition is designed to represent a 3-LED panel through three boolean request fields and a single boolean response field:</p> <ul> <li>Request</li> <li><code>lbit1</code> (bool): LED 1 command</li> <li><code>lbit2</code> (bool): LED 2 command</li> <li><code>lbit3</code> (bool): LED 3 command</li> <li>Response</li> <li><code>success</code> (bool): confirms whether the request was processed correctly</li> </ul> <p>Is important to consider that request/response field names were written using lowercase letters and without symbols to avoid build/compilation issues in the ROS 2 interface generation pipeline.</p> <pre><code>bool lbit1\nbool lbit2\nbool lbit3\n---\nbool success\n</code></pre>"},{"location":"ROS2_Custom_Interfaces/#message-definition-batstatusmsg","title":"Message definition: <code>BatStatus.msg</code>","text":"<p>The LED panel state is published as a custom message with three <code>int8</code> fields:</p> <ul> <li><code>led1</code> (int8): LED 1 state (0/1)</li> <li><code>led2</code> (int8): LED 2 state (0/1)</li> <li><code>led3</code> (int8): LED 3 state (0/1)</li> </ul> <pre><code>int8 led1\nint8 led2\nint8 led3\n</code></pre> <p>This representation is intentionally minimal: each LED state is expressed as a numeric bit (0 = OFF, 1 = ON).</p> <p>Finally, to generate and use these interfaces, the <code>.msg</code> and <code>.srv</code> paths must be registered in the interface generation section (<code>rosidl_generate_interfaces(...)</code>) in <code>CMakeLists.txt</code>.</p> <pre><code>rosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/BatStatus.msg\"\n  \"srv/LEDpanel.srv\"\n  #Remaining file paths\n)\n</code></pre>"},{"location":"ROS2_Custom_Interfaces/#node-1-led-panel-node-service-server-state-publisher","title":"Node 1 \u2014 LED Panel Node (Service Server + State Publisher)","text":"<p>The <code>LED_panel_node</code> is responsible for two roles:</p> <ol> <li>Hosting the <code>/set_led</code> service server (custom type <code>LEDpanel</code>)</li> <li>Publishing the LED panel state on the <code>/led_panel_state</code> topic (custom type <code>BatStatus</code>)</li> </ol> <p>Also, instead of publishing panel state continuously with a timer, this node publishes only when there is a meaningful change (when a service request arrives). This avoids sending redundant messages and keeps the topic output focused on actual state transitions.</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom er_interfaces.srv import LEDpanel\nfrom er_interfaces.msg import BatStatus\n\nclass MyPanel(Node):\n    def __init__(self):\n        super().__init__(\"LED_panel_node\") #Only identification\n\n        self.server = self.create_service(LEDpanel,\"set_led\", self.set_status)\n        self.publisher_ = self.create_publisher(BatStatus, \"led_panel_state\", 10)\n\n        self.get_logger().info(\"LEDs Panel ready\")\n\n    def set_status(self, request: LEDpanel.Request, response: LEDpanel.Response):\n        msg = BatStatus()\n\n        if (request.lbit3):\n            msg.led3 = 1\n        else:\n            msg.led3 = 0\n\n        self.publisher_.publish(msg)\n        self.get_logger().info(f\"{msg.led1} | {msg.led2} | {msg.led3}\")\n\n        response.success = True\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    LED_panel_node = MyPanel()\n    rclpy.spin(LED_panel_node) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":  \n    main()\n</code></pre>"},{"location":"ROS2_Custom_Interfaces/#service-callback-behavior-set_status","title":"Service callback behavior (<code>set_status</code>)","text":"<p>When the service receives a request:</p> <ul> <li>A <code>BatStatus</code> message is created.</li> <li>The requested LED bit is translated into a <code>0/1</code> value in the corresponding <code>msg.ledX</code> field.</li> <li>The message is published to <code>/led_panel_state</code>.</li> <li>A logger prints a simple \u201cpanel visualization\u201d in the terminal (useful as a lightweight debugger).</li> <li><code>response.success</code> is set to <code>True</code> and returned to the client.</li> </ul> <p>For simplicity, the callback only evaluates <code>request.lbit3</code>, meaning the logic toggles only the least significant bit (LED 3). LEDs 1 and 2 remain available in the interface design but are not used in the current implementation.</p>"},{"location":"ROS2_Custom_Interfaces/#node-2-battery-node-service-client-battery-simulation","title":"Node 2 \u2014 Battery Node (Service Client + Battery Simulation)","text":"<p>The <code>Battery_node</code> simulates battery life and triggers LED changes by calling the <code>/set_led</code> service.</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom er_interfaces.srv import LEDpanel\nfrom functools import partial\n\nclass MyBat(Node):\n    def __init__(self):\n        super().__init__(\"Battery_node\") #Only identification          \n        self.client = self.create_client(LEDpanel,\"set_led\") #Service type, Service name\n\n        self.level = 100\n        self.create_timer(0.1, self.bat_level)\n\n    def call_status_alert(self, lbit3: bool):\n        while not self.client.wait_for_service(timeout_sec = 1.0):\n            self.get_logger().info(\"Server not available\")\n\n        request = LEDpanel.Request()\n        request.lbit3 = lbit3\n\n        self.future = self.client.call_async(request)   #asyncronous request\n        self.future.add_done_callback(partial(self.add_status_alert, request))\n\n    def add_status_alert(self, request: LEDpanel.Request, future):\n        response = future.result()\n        self.get_logger().info(f\"S: {response.success}, lbit3={request.lbit3}\")\n\n    def bat_level(self):\n        self.level -= 1\n        if (self.level == 60):\n            self.call_status_alert(False)\n        elif (self.level == 0): \n            self.level = 100\n            self.call_status_alert(True)\n\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    Battery_node = MyBat()\n    rclpy.spin(Battery_node) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":  \n    main()\n</code></pre>"},{"location":"ROS2_Custom_Interfaces/#service-call-workflow-call_status_alert-add_status_alert","title":"Service-call workflow (<code>call_status_alert</code> + <code>add_status_alert</code>)","text":"<ul> <li>Wait for server: <code>call_status_alert()</code> uses <code>wait_for_service()</code> to ensure <code>/set_led</code> is available (prints a message if not).</li> <li>Build request: creates <code>LEDpanel.Request()</code> and assigns <code>request.lbit3</code> from the input boolean (<code>True</code> = ON, <code>False</code> = OFF).</li> <li>Send asynchronously: calls <code>call_async(request)</code> so the node keeps running while the request is processed.</li> <li>Handle response: <code>add_status_alert()</code> retrieves <code>future.result()</code> and logs <code>success</code> plus the requested <code>lbit3</code> value for verification.</li> </ul>"},{"location":"ROS2_Custom_Interfaces/#battery-simulation-approach","title":"Battery simulation approach","text":"<p>A timer runs every 100 ms (0.1 s) and executes a battery update function:</p> <ul> <li><code>self.level</code> starts at 100</li> <li>Each timer tick decrements the level by 1</li> <li>When specific thresholds are reached, the node sends a service request to the LED panel</li> </ul> <p>This timer-driven logic emulates a battery discharge/charge cycle without requiring real sensor input. The thresholds act as \u201cevents\u201d that trigger service calls. The battery node sends requests using an asynchronous service call (<code>call_async</code>). When the service returns a response the callback prints confirmation info (<code>success</code>) along with the request bit that was sent (<code>lbit3</code>), allowing quick validation that the interaction worked as expected.</p>"},{"location":"ROS2_Custom_Interfaces/#terminal-commands","title":"Terminal Commands","text":"<ol> <li> <p>Run the nodes</p> <ul> <li> <p>LED_panel_node node <pre><code>ros2 run er_pkg LED_panel_node \n</code></pre></p> </li> <li> <p>Battery_node node <pre><code>ros2 run er_pkg Battery_node\n</code></pre></p> </li> </ul> </li> <li> <p>Verifying the System Graph and topic msg</p> <ul> <li>Topic msg <pre><code>ros2 topic echo /led_panel_state\n</code></pre></li> <li>System Graph <pre><code>rqt_graph\n</code></pre></li> </ul> </li> </ol>"},{"location":"ROS2_Custom_Interfaces/#results-terminal-and-rqt_graph","title":"Results (Terminal and rqt_graph)","text":""},{"location":"ROS2_Services/","title":"(A2) Activity 2: ROS 2 Services","text":""},{"location":"ROS2_Services/#overview","title":"Overview","text":"<p>In this activity we extend a topic-based pipeline by adding a ROS 2 service that can reset the counter without stopping either node.</p> <p>We need two Python nodes:</p> <ol> <li> <p>Node 1: <code>number_publisher</code> </p> <ul> <li>Publishes an Int64 message on <code>/number</code> every 1 second.</li> </ul> </li> <li> <p>Node 2: <code>number_counter</code> (subscriber + publisher + service server)  </p> <ul> <li>Subscribes to <code>/number</code> (Int64).</li> <li>Accumulates the received value into an internal variable (the counter).</li> <li>Republishes the accumulated value on <code>/number_count</code> (Int64) every 0.5 seconds.</li> <li>Provides a service server <code>/reset_counter</code> of type example_interfaces/srv/SetBool to reset the accumulator to zero on demand.</li> </ul> </li> </ol> <p>Conceptually, it should show the following workflow:</p> <p></p>"},{"location":"ROS2_Services/#service-type","title":"Service type","text":"<p>In this activity I used the server example_interfaces/srv/SetBool type. This service provides:</p> <ul> <li>Request: a boolean field (data)</li> <li>Response: a boolean flag (success) and a string (message)</li> </ul> <p>You can inspect it directly with:</p> <pre><code>ros2 interface show example_interfaces/srv/SetBool\n</code></pre>"},{"location":"ROS2_Services/#code","title":"Code","text":"<ol> <li>Publisher node</li> </ol> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\nclass MyPublisher(Node):\n    def __init__(self):\n        super().__init__(\"number_publisher\")\n        self.cnt = 0\n        self.get_logger().info(\"number_publisher is alive\")\n        self.create_timer(1.0, self.talk)\n        self.publisher_ = self.create_publisher(Int64, \"number\", 10)\n\n    def talk(self):\n        msg = Int64()\n        msg.data = self.cnt\n        self.cnt = 1\n        self.get_logger().info(\"I said: \"\"Say: \" + str(msg.data))\n        self.publisher_.publish(msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    number_publisher = MyPublisher()\n    rclpy.spin(number_publisher) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The code creates a publisher (<code>number_publisher</code>) that sends integer messages on the <code>/number</code> topic using <code>example_interfaces/Int64</code>. A timer calls <code>talk()</code> once per second, where an <code>Int64</code> message is created, its <code>data</code> field is filled with the current value of <code>self.cnt</code>, the value is logged, and then published. In this implementation, after the first publish the variable is forced to <code>1</code> (<code>self.cnt = 1</code>), so the node effectively outputs a constant increment tick (0 once, then 1 repeatedly). The <code>main()</code> function initializes ROS 2, instantiates the node, keeps it running with <code>rclpy.spin()</code>, and shuts down cleanly.</p> <ol> <li>Publisher, subscriber and server node</li> </ol> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool\n\nclass MyPublisher(Node):\n    def __init__(self):\n        super().__init__(\"number_counter\")\n        self.cntP = 0\n        self.get_logger().info(\"number_counter is alive\")\n        self.create_timer(0.5, self.talk)\n\n        self.publisher_ = self.create_publisher(Int64, \"number_count\", 10)\n        self.subscriber = self.create_subscription(Int64,\"number\", self.listen, 10)\n        self.server = self.create_service(SetBool,\"reset_counter\", self.call_reset) #Service type, Service name, callback\n\n    def call_reset(self, request: SetBool.Request, response: SetBool.Response):\n        if (request.data):\n            self.cntP = 0\n            request.data = False\n            response.message = \"Reset\"\n        else:\n            response.message = \"War never changes\"\n\n        return response\n\n    def listen(self, msg: Int64):\n        self.get_logger().info(str(msg.data))\n        self.cntP = self.cntP + msg.data\n\n    def talk(self):\n        msg = Int64()\n        msg.data = self.cntP\n        self.get_logger().info(\"number_publisher is saying: \" + str(msg.data))\n        self.publisher_.publish(msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    number_counter = MyPublisher()\n    rclpy.spin(number_counter) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The second code creates the <code>number_counter</code> node, which combines a subscriber, a publisher, and a service server. It subscribes to <code>/number</code> (<code>Int64</code>) and, every time a message arrives, the <code>listen()</code> callback logs the incoming integer and accumulates it into <code>self.cntP</code> (<code>self.cntP = self.cntP + msg.data</code>). In parallel, a timer calls <code>talk()</code> every 0.5 seconds to publish the current accumulated value on <code>/number_count</code> using <code>example_interfaces/Int64</code>.</p> <pre><code>    def call_reset(self, request: SetBool.Request, response: SetBool.Response):\n        if (request.data):\n            self.cntP = 0\n            request.data = False\n            response.message = \"Reset\"\n        else:\n            response.message = \"War never changes\"\n\n        return response\n</code></pre> <p>Additionally, the node exposes the <code>/reset_counter</code> service with type <code>example_interfaces/srv/SetBool</code>. When the service is called, the callback <code>call_reset()</code> checks <code>request.data</code>: if it is <code>true</code>, the node resets the accumulator (<code>self.cntP = 0</code>) and returns a response message <code>\"Reset\"</code>; otherwise it leaves the counter unchanged and responds with <code>\"War never changes\"</code>. As before, <code>main()</code> initializes ROS 2, spins the node to keep callbacks active (topics + service), and shuts down on exit.</p>"},{"location":"ROS2_Services/#terminal-commands","title":"Terminal Commands","text":"<ol> <li> <p>Run the nodes</p> <ul> <li> <p>number_publisher node <pre><code>ros2 run er_pkg p2d2 \n</code></pre></p> </li> <li> <p>number_counter node <pre><code>ros2 run er_pkg h1\n</code></pre></p> </li> </ul> </li> <li> <p>Calling the Reset Service from the CLI To request a reset (send data: true): <pre><code>ros2 service call /reset_counter example_interfaces/srv/SetBool \"{data: true}\"\n</code></pre></p> </li> <li> <p>Verifying the System Graph <pre><code>rqt_graph\n</code></pre></p> </li> </ol>"},{"location":"ROS2_Services/#results-terminal-and-rqt_graph","title":"Results (Terminal and rqt_graph)","text":""},{"location":"ROS2_Topics/","title":"(A1) Activity 1: ROS 2 Topics","text":""},{"location":"ROS2_Topics/#overview","title":"Overview","text":"<p>This activity demonstrates basic ROS 2 communication using topics by creating two Python nodes:</p> <ul> <li> <p>Node 1: <code>number_publisher</code>   Publishes an increasing counter on <code>/number</code> every 1 second.</p> </li> <li> <p>Node 2: <code>number_counter</code> (subscriber + publisher)   Subscribes to <code>/number</code> and republishes the received value on <code>/number_count</code>.</p> </li> </ul> <p>Conceptually: </p> <p>Next, we implement the nodes in code. We begin with the publisher (<code>number_publisher</code>).</p>"},{"location":"ROS2_Topics/#code","title":"Code","text":"<ol> <li>Publisher node</li> </ol> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\nclass MyPublisher(Node):\n    def __init__(self):\n        super().__init__(\"number_publisher\")\n        self.cnt = 0\n        self.get_logger().info(\"number_publisher is alive\")\n        self.create_timer(1.0, self.talk)\n        self.publisher_ = self.create_publisher(String, \"number\", 10)\n\n    def talk(self):\n        msg = String()\n        msg.data = str(self.cnt)\n        self.cnt += 1\n        self.get_logger().info(\"I said: \" + msg.data)\n        self.publisher_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    number_publisher = MyPublisher()\n    rclpy.spin(number_publisher)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The code creates a publisher (<code>number_publisher</code>)  that sends a counter value on the <code>/number</code> topic using <code>example_interfaces/String</code>. A timer calls <code>talk()</code> once per second, where the message is filled with the current counter, logged, published, and then incremented. The <code>main()</code> function initializes ROS 2, keeps the node running with <code>rclpy.spin()</code>.</p> <ol> <li>Publisher and subscriber node</li> </ol> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\nclass MyPublisher(Node):\n    def __init__(self):\n        super().__init__(\"number_counter\")\n        self.cnt = 0\n        self.get_logger().info(\"number_counter is alive\")\n        self.create_timer(1.0, self.talk)\n        self.publisher_ = self.create_publisher(String, \"number_count\", 10)\n        self.subscriber = self.create_subscription(String,\"number\", self.listen, 10)\n\n    def listen(self, msg: String):\n        self.get_logger().info(msg.data) #print the data field\n        self.cnt = int(msg.data)\n\n    def talk(self):\n        msg = String()\n        msg.data = str(self.cnt)\n        self.get_logger().info(\"number_publisher is saying: \" + msg.data)\n        self.publisher_.publish(msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    number_counter = MyPublisher()\n    rclpy.spin(number_counter) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The second node (<code>number_counter</code>) completes the pipeline by subscribing to the <code>/number</code> topic published by <code>number_publisher</code> and then republishing the received value on <code>/number_count</code>.</p> <pre><code>    def listen(self, msg: String):\n        self.get_logger().info(msg.data) #print the data field\n        self.cnt = int(msg.data)\n</code></pre> <p>The <code>listen()</code> callback runs every time a message arrives on <code>/number</code>, logs the incoming data, and stores it in <code>self.cnt</code> (converted back to an integer).</p> <pre><code>    def talk(self):\n        msg = String()\n        msg.data = str(self.cnt)\n        self.get_logger().info(\"number_publisher is saying: \" + msg.data)\n        self.publisher_.publish(msg)\n</code></pre> <p>A timer calls <code>talk()</code> once per second to publish the current stored value to <code>/number_count</code>, allowing other nodes (or <code>ros2 topic echo</code>) to read the forwarded counter. As before, <code>main()</code> initializes ROS 2, keeps the node running with <code>rclpy.spin()</code>, and shuts down cleanly.</p>"},{"location":"ROS2_Topics/#results-terminal-and-rqt_graph","title":"Results (Terminal and rqt_graph)","text":""},{"location":"comandos/","title":"CMDs","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"Project example (WP)","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"}]}